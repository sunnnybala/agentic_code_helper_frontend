import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import axios from 'axios';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import detectLang from 'lang-detector';
import './App.css';
import Header from './components/Header';
import BuyCredits from './components/Billing/BuyCredits';
import PolicyMenu from './components/PolicyMenu';
import { useAuth } from './context/AuthContext';
console.log('App initialized');
function App() {
  const { user, logout, refresh } = useAuth();
  const [files, setFiles] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState(null);
  const [error, setError] = useState('');
  const [previews, setPreviews] = useState([]);
  const [model, setModel] = useState('gpt-5-nano');
  const [additionalInstructions, setAdditionalInstructions] = useState('');
  const [progress, setProgress] = useState({
    imageProcessed: false,
    codeGenerated: false,
    testCasesGenerated: false,
    solutionSelected: false
  });
  const solutionRef = useRef(null);

  const handleFileChange = (e) => {
    const newFiles = Array.from(e.target.files).slice(0, 3); // Limit to 3 files
    
    // Create previews for the selected files
    const newPreviews = newFiles.map(file => ({
      name: file.name,
      url: URL.createObjectURL(file)
    }));
    
    setFiles(newFiles);
    setPreviews(newPreviews);
    setError('');
  };

  // Cleanup object URLs when component unmounts
  useEffect(() => {
    return () => {
      previews.forEach(preview => {
        URL.revokeObjectURL(preview.url);
      });
    };
  }, [previews]);
  useEffect(() => {
    if (result && solutionRef.current) {
      solutionRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [result]);

  const removeFile = (index) => {
    const newFiles = [...files];
    const newPreviews = [...previews];
    
    // Revoke the object URL to avoid memory leaks
    URL.revokeObjectURL(newPreviews[index].url);
    
    newFiles.splice(index, 1);
    newPreviews.splice(index, 1);
    
    setFiles(newFiles);
    setPreviews(newPreviews);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (files.length === 0) {
      setError('Please select at least one image file');
      return;
    }

    if (!model.trim()) {
      setError('Please specify a model to use');
      return;
    }

    const formData = new FormData();
    files.forEach((file) => {
      formData.append('images', file);
    });
    formData.append('model', model);
    if (additionalInstructions.trim()) {
      formData.append('additionalInstructions', additionalInstructions);
    }

    setIsLoading(true);
    setError('');
    setResult(null);
    setProgress({
      imageProcessed: false,
      codeGenerated: false,
      testCasesGenerated: false,
      solutionSelected: false
    });

    try {
      // Use the environment variable for the API URL
      const apiUrl = import.meta.env.VITE_API_URL || '';
      
      // RequestId is generated by the server; allow server to return it in the response.
      // But to receive scoped progress updates, we can create a provisional requestId
      // client-side and send it with the upload; the server will use it if provided.
      const provisionalRequestId = `c${Date.now().toString(36)}${Math.random().toString(36).slice(2)}`;

      // SSE connection with token refresh and reconnect logic.
      // The token endpoint returns a short-lived JWT (default 300s). We refresh
      // it shortly before expiry and reconnect the EventSource. Exponential
      // backoff is used for reconnect attempts.
      let eventSource = null;
      let retryCount = 0;
      const maxRetries = 6; // stops after ~1min of attempts (1s->64s)
      const baseDelay = 1000; // ms
      const SSE_TOKEN_TTL = 300; // seconds (should match server)
      const SSE_REFRESH_MARGIN = 30; // seconds before expiry to refresh
      let refreshTimer = null;
      let stopped = false; // set true when we intentionally close the connection

      const closeSSE = () => {
        stopped = true;
        if (eventSource) try { eventSource.close(); } catch (_) {}
        eventSource = null;
        if (refreshTimer) { clearTimeout(refreshTimer); refreshTimer = null; }
      };

      const scheduleTokenRefresh = (onRefresh) => {
        if (refreshTimer) clearTimeout(refreshTimer);
        const ms = Math.max(1000, (SSE_TOKEN_TTL - SSE_REFRESH_MARGIN) * 1000);
        refreshTimer = setTimeout(() => {
          onRefresh().catch((e) => {
            console.error('SSE token refresh failed', e);
          });
        }, ms);
      };

      const openSSEWithToken = async () => {
        if (stopped) return;
        try {
          const tokenResp = await axios.get(`${apiUrl}/auth/stream-token`, { withCredentials: true });
          const token = tokenResp?.data?.token;
          const url = token
            ? `${apiUrl}/api/progress?requestId=${provisionalRequestId}&token=${encodeURIComponent(token)}`
            : `${apiUrl}/api/progress?requestId=${provisionalRequestId}`;

          // Close any existing connection before opening a new one
          if (eventSource) try { eventSource.close(); } catch (_) {}

          eventSource = new EventSource(url);

          // Reset retry counter on successful open
          retryCount = 0;

          // Schedule a token refresh shortly before expiry
          if (token) scheduleTokenRefresh(async () => {
            if (stopped) return;
            try {
              // fetch new token and re-open connection
              const refreshed = await axios.get(`${apiUrl}/auth/stream-token`, { withCredentials: true });
              const newToken = refreshed?.data?.token;
              if (!newToken) throw new Error('no token');
              // open new connection using the new token
              await openSSEWithToken();
            } catch (e) {
              console.error('Failed to refresh SSE token', e);
            }
          });

          // Attach handlers (they will be replaced if we re-open connection)
          eventSource.onmessage = (event) => {
            try {
              const update = JSON.parse(event.data);
              const { event: evt, requestId: sid, ...rest } = update;
              if (evt === 'completed') {
                setProgress(prev => ({
                  ...prev,
                  imageProcessed: true,
                  codeGenerated: true,
                  testCasesGenerated: true,
                  solutionSelected: true
                }));
                return;
              }
              setProgress(prev => ({ ...prev, ...rest }));
            } catch (e) {
              console.error('Failed to parse SSE message', e);
            }
          };

          eventSource.onerror = () => {
            try { eventSource.close(); } catch (_) {}
            eventSource = null;
            if (stopped) return;
            // schedule reconnect with exponential backoff
            if (retryCount <= maxRetries) {
              const delay = Math.min(60000, baseDelay * Math.pow(2, retryCount));
              retryCount += 1;
              setTimeout(() => { openSSEWithToken().catch(() => {}); }, delay);
            } else {
              console.error('SSE reconnect attempts exhausted');
            }
          };

        } catch (err) {
          console.error('Failed to open SSE connection with token:', err);
          // fallback to direct SSE without token in non-prod environments
          if (process.env.NODE_ENV !== 'production') {
            try {
              if (eventSource) try { eventSource.close(); } catch (_) {}
              eventSource = new EventSource(`${apiUrl}/api/progress?requestId=${provisionalRequestId}`);
            } catch (e) {
              console.error('Fallback direct SSE open failed', e);
            }
          }
        }
      };

      // Start the connection
      await openSSEWithToken();
      
      eventSource.onmessage = (event) => {
        try {
          const update = JSON.parse(event.data);
          // Ignore the server's completion event payload if it carries meta fields
          const { event: evt, requestId: sid, ...rest } = update;
          if (evt === 'completed') {
            // optionally handle completion UI here (server also returns final response)
            setProgress(prev => ({
              ...prev,
              imageProcessed: true,
              codeGenerated: true,
              testCasesGenerated: true,
              solutionSelected: true
            }));
            return;
          }
          setProgress(prev => ({
            ...prev,
            ...rest
          }));
        } catch (e) {
          console.error('Failed to parse SSE message', e);
        }
      };
      
      eventSource.onerror = (error) => {
        console.error('EventSource failed:', error);
        eventSource.close();
      };
      
      // Include the provisionalRequestId in the upload payload so server sends
      // updates to clients subscribed to this id
      formData.append('requestId', provisionalRequestId);
      const response = await axios.post(
        `${apiUrl}/api/upload`, 
        formData, 
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
          withCredentials: true
        }
      );
      
      // Close the event source when done
      eventSource.close();
      
      if (!response.data.success) {
        throw new Error(response.data.error || 'Unknown error occurred');
      }

      setResult(response.data);
      // Refresh user data (credits) after successful processing
      try { refresh(); } catch (_) {}
      
      // Scroll to solution when complete
      
    } catch (err) {
      console.error('Full error:', err);
      console.error('Error response:', err.response);
      
      const errorMessage = err.response?.data?.error || 
                         err.response?.data?.details || 
                         err.message || 
                         'An error occurred while processing the images';
      setError(`Error: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="app">
      <Header />
      <header style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <div>
          <h1>Code Turtle</h1>
          <p className="motto">slow and steady wins the race</p>
          {user && (
            <p className="user-info">Hi, {user.username} • Credits: {user.credits}</p>
          )}
          <p>Upload an image of a coding problem and get it solved by a team of AI agents</p>
        </div>
        <PolicyMenu />
      </header>
      
      <div className="configuration-card">
        <h3>Configuration</h3>
        <div className="config-fields">
          <div className="form-group">
            <label htmlFor="model">AI Model</label>
            <select
              id="model"
              value={model}
              onChange={(e) => setModel(e.target.value)}
              className="form-control"
            >
              <option value="gpt-5-nano">Low reasoning - 5₹ (1 credit)</option>
              <option value="gpt-5-mini">Medium reasoning - 15₹ (3 credits)</option>
              <option value="gpt-5">High reasoning - 50₹ (10 credits)</option>
            </select>
            <div className="hint">Choose reasoning level (cost shown in INR and credits)</div>
          </div>
           
          <div className="form-group">
            <label htmlFor="instructions">Additional Instructions</label>
            <textarea
              id="instructions"
              value={additionalInstructions}
              onChange={(e) => setAdditionalInstructions(e.target.value)}
              placeholder="Any specific instructions or requirements for the solution..."
              className="form-control"
              rows="2"
            />
            <div className="hint">Optional: Add any specific requirements or constraints</div>
          </div>
        </div>
      </div>

      <main>
        <form onSubmit={handleSubmit} className="upload-form">
          <div className="file-input">
            <input
              type="file"
              id="image-upload"
              accept="image/*"
              onChange={handleFileChange}
              disabled={isLoading || previews.length >= 3}
              multiple
            />
            <label htmlFor="image-upload">
              {previews.length > 0 
                ? `Selected ${previews.length} file${previews.length > 1 ? 's' : ''}` 
                : 'Choose 1-3 images...'}
            </label>
            
            {previews.length > 0 && (
              <div className="file-previews">
                {previews.map((preview, index) => (
                  <div key={index} className="file-preview">
                    <img 
                      src={preview.url} 
                      alt={`Preview ${index + 1}`} 
                      className="preview-image"
                    />
                    <span className="file-name">{preview.name}</span>
                    <button 
                      type="button" 
                      className="remove-file"
                      onClick={() => removeFile(index)}
                      disabled={isLoading}
                    >
                      ×
                    </button>
                  </div>
                ))}
              </div>
            )}
            
            {previews.length > 0 && (
              <p className="hint">
                {3 - previews.length} more image{3 - previews.length !== 1 ? 's' : ''} can be added
              </p>
            )}
          </div>
          
          <div className="form-actions">
            <button type="submit" disabled={isLoading || files.length === 0 || !user}>
              {isLoading ? 'Processing...' : (!user ? 'Login to Solve' : 'Solve Problem')}
            </button>

            <div className="post-actions">
              <div className="buy-and-logout">
                {user && (
                  <>
                    <div className="buy-row">
                      <BuyCredits />
                    </div>
                    <div className="logout-row">
                      <button type="button" className="logout-cta" onClick={() => logout()}>
                        Logout
                      </button>
                    </div>
                  </>
                )}
              </div>
            </div>
          </div>

          {error && <p className="error">{error}</p>}
        </form>

        {isLoading && (
          <div className="loading">
            <div className="spinner"></div>
            <p>Analyzing your problem with AI agents...</p>
            <div className="progress-steps">
              <div className={`progress-step ${progress.imageProcessed ? 'completed' : ''}`}>
                <span className="step-number">1</span>
                <span className="step-text">Image Processed</span>
              </div>
              <div className={`progress-step ${progress.codeGenerated ? 'completed' : ''}`}>
                <span className="step-number">2</span>
                <span className="step-text">Code Generated</span>
              </div>
              <div className={`progress-step ${progress.testCasesGenerated ? 'completed' : ''}`}>
                <span className="step-number">3</span>
                <span className="step-text">Test Cases Generated</span>
              </div>
              <div className={`progress-step ${progress.solutionSelected ? 'completed' : ''}`}>
                <span className="step-number">4</span>
                <span className="step-text">Best Solution Selected</span>
              </div>
            </div>
          </div>
        )}

        {result && (
          <div className="result" >
            {result.problemStatement && (
              <div className="problem-statement">
                <h2>Problem Statement</h2>
                <div className="problem-content">
                  <pre>{result.problemStatement}</pre>
                </div>
              </div>
            )}
            
            <div className="solution-section" ref={solutionRef}>
              <h2>Solution</h2>
              <div className="code-block">
                <CodeBlock 
                  code={result.solution.bestSolution} 
                  language={result.language || 'javascript'} 
                />
              </div>
            </div>
            
            {result.testCases && result.testCases.length > 0 && (
              <div className="test-cases">
                <h3>Test Cases</h3>
                <div className="test-cases-grid">
                  {result.testCases.map((testCase, index) => (
                    <div key={index} className="test-case">
                      <h4>Test Case {index + 1}</h4>
                      <p><strong>Input:</strong> {JSON.stringify(testCase.input)}</p>
                      <p><strong>Expected Output:</strong> {JSON.stringify(testCase.expected)}</p>
                      {testCase.description && <p><em>{testCase.description}</em></p>}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </main>

      <footer>
        <p>AI Code Solver - Upload an image of a coding problem to get started</p>
      </footer>
    </div>
  );
}

// Component to handle syntax highlighting with language detection
function CodeBlock({ code, language: defaultLanguage = 'python' }) {
  // Try to detect the language if not provided
  const detectedLanguage = useMemo(() => {
    if (!code) return defaultLanguage;
    try {
      const detected = detectLang(code);
      // Map some common language names to Prism.js supported ones
      const langMap = {
        'javascript': 'javascript',
        'js': 'javascript',
        'python': 'python',
        'py': 'python',
        'java': 'java',
        'c++': 'cpp',
        'cpp': 'cpp',
        'c': 'c',
        'c#': 'csharp',
        'csharp': 'csharp',
        'go': 'go',
        'ruby': 'ruby',
        'rust': 'rust',
        'php': 'php',
        'typescript': 'typescript',
        'ts': 'typescript',
        'swift': 'swift',
        'kotlin': 'kotlin',
        'scala': 'scala',
        'r': 'r',
        'objective-c': 'objectivec',
        'objectivec': 'objectivec',
        'bash': 'bash',
        'shell': 'bash',
        'sql': 'sql',
        'html': 'html',
        'css': 'css',
        'json': 'json',
        'yaml': 'yaml',
        'markdown': 'markdown',
        'md': 'markdown',
      };
      
      return langMap[detected.toLowerCase()] || defaultLanguage;
    } catch (e) {
      console.error('Error detecting language:', e);
      return defaultLanguage;
    }
  }, [code, defaultLanguage]);

  return (
    <SyntaxHighlighter 
      language={detectedLanguage}
      style={oneDark}
      showLineNumbers={true}
      wrapLines={true}
      customStyle={{
        margin: 0,
        borderRadius: '6px',
        fontSize: '0.9em',
        lineHeight: '1.5',
      }}
      codeTagProps={{
        style: {
          fontFamily: 'Fira Code, monospace',
        },
      }}
    >
      {code}
    </SyntaxHighlighter>
  );
}

export default App;
